---
# roles/ubuntu/tasks/system/discover.yaml
# Collects system health metrics (Disk, Memory, Services, Uptime)

# ========================================================================
# 1. COLLECTION
# ========================================================================

- name: Gather System Facts (Hardware/Network)
  ansible.builtin.setup:
    gather_subset:
      - 'hardware'
      - 'mounts'
      - 'network'

- name: Check for Failed Systemd Services
  # We use command because the systemd module cannot 'list' all failed units
  ansible.builtin.command: systemctl list-units --state=failed --no-legend --plain
  register: _failed_services_raw
  changed_when: false
  # IGNORE LINT: Intentional use of command to list units
  tags: [skip_ansible_lint]

- name: Collect User Database (getent)
  ansible.builtin.getent:
    database: passwd

- name: Read /etc/shadow (for password aging/locking)
  ansible.builtin.command: cat /etc/shadow
  register: _shadow_raw
  become: true
  changed_when: false
  no_log: true # PROTECT HASHES

- name: Collect Running SSH Configuration
  ansible.builtin.command: sshd -T
  register: _sshd_raw
  become: true
  changed_when: false

- name: Check permissions of critical files
  ansible.builtin.stat:
    path: "{{ item }}"
  register: _file_stats_raw
  loop:
    - /etc/shadow
    - /etc/passwd
    - /etc/ssh/sshd_config

- name: Scan for world-writable files (Time Limited)
  ansible.builtin.command: find /etc /var -xdev -type f -perm -0002 -print
  register: _world_writable_raw
  become: true
  changed_when: false
  failed_when: _world_writable_raw.rc is defined and _world_writable_raw.rc != 0
  async: 10
  poll: 1

# 1. UPDATE CACHE
- name: Update apt cache (Force Refresh)
  ansible.builtin.apt:
    update_cache: yes
    cache_valid_time: 0
  changed_when: false
  become: true

# 2. CHECK REBOOT STATUS (Moved up for cleaner logic flow)
- name: Check if reboot is required
  ansible.builtin.stat:
    path: /var/run/reboot-required
  register: _reboot_stat

# 3. CHECK UPDATES
- name: Check for upgradable packages (Dry Run)
  # -s = simulate. Returns the plan without modifying the system.
  ansible.builtin.command: apt-get -s upgrade
  register: _apt_simulate
  changed_when: false
  # Prevent failure if apt lock is held by auto-updates
  failed_when: _apt_simulate.rc != 0 and 'Could not get lock' not in _apt_simulate.stderr
  # FIX: Tell linter this command usage is intentional
  tags: [skip_ansible_lint]

# 4. NORMALIZE DATA
- name: Parse and store update metrics
  ansible.builtin.set_fact:
    ubuntu: "{{ ubuntu | combine({'updates': update_data}, recursive=true) }}"
  vars:
    # Robust extraction: Find the line "X upgraded, Y newly installed..."
    # 'default' prevents crashes if apt output is non-standard
    _summary_line: "{{ _apt_simulate.stdout_lines | select('search', 'upgraded,') | list | last | default('0') }}"
    _count_raw: "{{ _summary_line.split()[0] | default('0') }}"

    update_data:
      pending_count: "{{ _count_raw | int }}"
      reboot_pending: "{{ _reboot_stat.stat.exists }}"
      # Optional: Capture the raw summary string for detailed logging later
      last_check_output: "{{ _summary_line }}"

- name: Log Patching Status
  ansible.builtin.debug:
    msg: "Updates Pending: {{ ubuntu.updates.pending_count }} | Reboot Required: {{ ubuntu.updates.reboot_pending }}"
