---
# roles/vsphere/tasks/init/main.yaml
# vSphere init entrypoint:
# 1) Overlay dynamic vcenter.connection + vcenter.check
# 2) Perform application-level API reachability check
# 3) If unreachable: emit alert + end_host

- name: Init | Overlay vCenter dynamic connection + check metadata
  ansible.builtin.set_fact:
    vcenter: "{{ (vcenter | default({})) | combine(_vcenter_dynamic, recursive=true) }}"
  vars:
    _hostname: >-
      {{
        (vcenter_url | default(ansible_host) | default(inventory_hostname))
        | regex_replace('^https?://', '')
        | regex_replace('/.*$', '')
      }}

    _vcenter_dynamic:
      connection:
        hostname: "{{ _hostname }}"
        port: "{{ (vcenter.connection.port | default(443)) | int }}"
        username: "{{ vcenter_username | default(vault_vcenters_user) }}"
        password: "{{ vcenter_password | default(vault_vcenters_password) }}"
        # defaults other tasks/templates can assume exist
        reachable: "{{ vcenter.connection.reachable | default(false) | bool }}"
        http_status: "{{ vcenter.connection.http_status | default('N/A') }}"

      check:
        started_at: "{{ ops.check.timestamp | default('') }}"
        date: "{{ ops.check.date | default('') }}"
        site: "{{ inventory_hostname }}"
  no_log: true

- name: Init | Check vCenter session endpoint (reachability)
  ansible.builtin.uri:
    url: "https://{{ vcenter.connection.hostname }}/rest/com/vmware/cis/session"
    method: POST
    user: "{{ vcenter.connection.username }}"
    password: "{{ vcenter.connection.password }}"
    validate_certs: "{{ (vcenter.config | default({})).get('validate_certs', false) | bool }}"
    force_basic_auth: true
    status_code: [200, 503]
    timeout: 15
    return_content: false
    use_proxy: false
  register: _vc_api
  delegate_to: localhost
  failed_when: false
  changed_when: false
  no_log: true
  check_mode: false


- name: Init | Update reachability status
  ansible.builtin.set_fact:
    vcenter: >-
      {{
        vcenter | combine({
          'connection': {
            'reachable': ((_vc_api.status | default(0)) in [200, 503]),
            'http_status': (_vc_api.status | default('N/A'))
          }
        }, recursive=true)
      }}
  no_log: true

- name: Init | Handle unreachable vCenter (alert + stop host)
  when:
    - not (vcenter.connection.reachable | default(false) | bool)
    - not ansible_check_mode
  block:
    - name: Log connectivity failure
      ansible.builtin.include_role:
        name: common
        tasks_from: logging/error
      vars:
        ops_log_message: >-
          Failed to connect to vCenter {{ vcenter.connection.hostname }}
          (HTTP {{ vcenter.connection.http_status }})

    - name: Emit CRITICAL alert
      ansible.builtin.include_role:
        name: common
        tasks_from: reporting/alert
      vars:
        ops_alert_severity: "CRITICAL"
        ops_alert_category: "connectivity"
        ops_alert_message: "vCenter {{ vcenter.connection.hostname }} is unreachable"
        ops_alert_details:
          hostname: "{{ vcenter.connection.hostname }}"
          status: "{{ vcenter.connection.http_status }}"
          msg: "{{ _vc_api.msg | default('Connection timed out/refused') }}"

    - name: Mark vCenter checks failed for this host
      ansible.builtin.set_fact:
        vcenter: "{{ vcenter | combine({'checks_failed': true}, recursive=true) }}"

    - name: Stop processing this host
      ansible.builtin.meta: end_host

- name: Init | Log connection parameters (debug only)
  ansible.builtin.include_role:
    name: common
    tasks_from: logging/debug
  vars:
    ops_log_message: "vCenter connection parameters configured"
    ops_log_context:
      hostname: "{{ vcenter.connection.hostname }}"
      validate_certs: "{{ (vcenter.config | default({})).get('validate_certs', false) | bool }}"
      http_status: "{{ vcenter.connection.http_status }}"
  when:
    - ((ops.config | default({})).get('debug_mode', false) | bool)
      or ((vcenter.config | default({})).get('debug_mode', false) | bool)
