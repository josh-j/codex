"""CKLB artifact generation for STIG results."""

import json
import re
from pathlib import Path
from typing import Any


def _strip_html(text: str) -> str:
    return re.sub(r"<[^>]+>", "", text)


def generate_cklb(
    hostname: str,
    audit_data: list[dict[str, Any]],
    skeleton_path: Path,
    output_path: Path,
    ip_address: str = "",
) -> None:
    """
    Generates a CKLB file from audit data and a skeleton.
    """
    if not skeleton_path.exists():
        raise FileNotFoundError(f"CKLB skeleton not found: {skeleton_path}")

    with open(skeleton_path) as f:
        skeleton = json.load(f)

    # Create map of results by rule ID (or version)
    # The skeleton usually uses 'rule_version' to match against the rule ID in our audit
    audit_map = {}
    for res in audit_data:
        rid = res.get("rule_id") or res.get("id")
        if rid:
            audit_map[str(rid).strip()] = res

    # Build the CKLB structure based on the skeleton
    cklb = {
        "title": skeleton.get("title"),
        "id": skeleton.get("id"),
        "cklb_version": skeleton.get("cklb_version"),
        "active": True,
        "mode": 1,
        "has_path": False,
        "target_data": {
            "target_type": "Computing",
            "host_name": hostname,
            "fqdn": hostname,
            "ip_address": ip_address,
            "role": "Workstation",
            "comments": "Generated by NCS Reporter",
        },
        "stigs": [],
    }

    for stig in skeleton.get("stigs", []):
        new_stig = {
            "stig_name": stig.get("stig_name"),
            "display_name": stig.get("display_name"),
            "stig_id": stig.get("stig_id"),
            "release_info": stig.get("release_info"),
            "version": stig.get("version"),
            "uuid": stig.get("uuid"),
            "size": stig.get("size"),
            "rules": [],
        }

        for rule in stig.get("rules", []):
            # Try to find a match in our audit data using several possible identifiers
            rule_version = str(rule.get("rule_version", "")).strip()
            rule_id = str(rule.get("rule_id", "")).strip()
            group_id = str(rule.get("group_id", "")).strip()

            audit_result = audit_map.get(rule_version) or audit_map.get(rule_id) or audit_map.get(group_id)

            status = "not_reviewed"
            details = ""
            comment = ""

            if audit_result:
                res_status = str(audit_result.get("status", "")).lower()
                if res_status in ["failed", "fail", "open"]:
                    status = "open"
                    raw_details = (
                        audit_result.get("checktext")
                        or audit_result.get("description")
                        or "Automated check identified a finding."
                    )
                    details = _strip_html(raw_details)
                    comment = "Automated Audit: Non-Compliant setting found."
                elif res_status in ["passed", "pass", "not_a_finding", "notafinding"]:
                    status = "not_a_finding"
                    raw_details = (
                        audit_result.get("checktext")
                        or audit_result.get("description")
                        or "Automated check verified compliance."
                    )
                    details = _strip_html(raw_details)
                    comment = "Automated Audit: Verified Compliant."

            new_rule = {
                "rule_id": rule.get("rule_id"),
                "rule_version": rule.get("rule_version"),
                "group_id": rule.get("group_id"),
                "status": status,
                "finding_details": details,
                "comments": comment,
                "severity": rule.get("severity"),
                "group_title": rule.get("group_title"),
                "rule_title": rule.get("rule_title"),
                "fix_text": rule.get("fix_text"),
                "check_content": rule.get("check_content"),
                "discussion": rule.get("discussion"),
                "cci_ref": (rule.get("ccis") or [""])[0],
            }
            rules_list = new_stig.get("rules")
            if isinstance(rules_list, list):
                rules_list.append(new_rule)

        stigs_list = cklb.get("stigs")
        if isinstance(stigs_list, list):
            stigs_list.append(new_stig)

    with open(output_path, "w") as f:
        json.dump(cklb, f, indent=2)
